# -*- coding: utf-8 -*-
"""Acv_LAB5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Rcoi9z5u6tv9n-1SvqoPTePydvawa4xD
"""

import cv2
import numpy as np
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.metrics import classification_report, roc_auc_score, confusion_matrix
import matplotlib.pyplot as plt

# Standard JPEG Quantization Matrix
QUANTIZATION_MATRIX = np.array([
    [16, 11, 10, 16, 24, 40, 51, 61],
    [12, 12, 14, 19, 26, 58, 60, 55],
    [14, 13, 16, 24, 40, 57, 69, 56],
    [14, 17, 22, 29, 51, 87, 80, 62],
    [18, 22, 37, 56, 68, 109, 103, 77],
    [24, 35, 55, 64, 81, 104, 113, 92],
    [49, 64, 78, 87, 103, 121, 120, 101],
    [72, 92, 95, 98, 112, 100, 103, 99]
])

def compress_image_jpeg(image_path, quality_factor=50):
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    image = np.float32(image) - 128
    h, w = image.shape

    # Ensure image dimensions are multiples of 8 by padding
    pad_h = (8 - h % 8) % 8
    pad_w = (8 - w % 8) % 8
    image_padded = np.pad(image, ((0, pad_h), (0, pad_w)), mode='constant', constant_values=0)

    h_p, w_p = image_padded.shape
    compressed_image = np.zeros((h_p, w_p), dtype=np.float32)

    scale = max(1, (100 - quality_factor) / 50)
    quant_matrix = np.round(QUANTIZATION_MATRIX * scale).astype(np.float32)

    for i in range(0, h_p, 8):
        for j in range(0, w_p, 8):
            block = image_padded[i:i+8, j:j+8]
            dct_block = cv2.dct(block)
            quantized_block = np.round(dct_block / quant_matrix)
            dequantized_block = quantized_block * quant_matrix
            compressed_image[i:i+8, j:j+8] = cv2.idct(dequantized_block) + 128

    compressed_image = compressed_image[:h, :w]
    compressed_image = np.clip(compressed_image, 0, 255).astype(np.uint8)
    cv2.imwrite("compressed.jpg", compressed_image)

# Task 1.2: Lossless Compression using PNG
def compress_image_png(image_path):
    image = cv2.imread(image_path)
    cv2.imwrite("compressed.png", image, [cv2.IMWRITE_PNG_COMPRESSION, 9])

# Task 2: CNN on MNIST and CIFAR-10
def train_cnn(dataset="mnist"):
    if dataset == "mnist":
        (x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
        x_train, x_test = x_train / 255.0, x_test / 255.0
        input_shape = (28, 28, 1)
    else:
        (x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()
        x_train, x_test = x_train / 255.0, x_test / 255.0
        input_shape = (32, 32, 3)

    x_train = np.expand_dims(x_train, -1) if dataset == "mnist" else x_train
    x_test = np.expand_dims(x_test, -1) if dataset == "mnist" else x_test

    model = keras.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),
        layers.MaxPooling2D((2, 2)),
        layers.Conv2D(64, (3, 3), activation='relu'),
        layers.MaxPooling2D((2, 2)),
        layers.Flatten(),
        layers.Dense(64, activation='relu'),
        layers.Dense(10, activation='softmax')
    ])

    model.compile(optimizer='adam',
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])

    history = model.fit(x_train, y_train, epochs=50, validation_split=0.2)

    y_pred = model.predict(x_test).argmax(axis=1)

    print("Classification Report:")
    print(classification_report(y_test, y_pred))
    print("Confusion Matrix:")
    print(confusion_matrix(y_test, y_pred))

    auc = roc_auc_score(y_test, keras.utils.to_categorical(y_pred, 10), multi_class='ovr')
    print(f"AUC Score: {auc}")

    return model

compress_image_jpeg("/content/signin-image.jpg")
compress_image_png("/content/signin-image.jpg")
model_mnist = train_cnn("mnist")
model_cifar10 = train_cnn("cifar10")